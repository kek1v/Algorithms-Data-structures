setlocale("LC_ALL,"Rus"); - чтобы русский язык понимало

cout<<"Ку\n\t"

\n - перенос на некст строку
\t - типа пробел

можно ставить перед выводимым обьектом

--------------------------------------

чтобы создать переменную нужно тип данных(int,bool,float и тд) и название переменной;

переменной задаётся значение как в пайтоне тольео в конце ;
a = 5;

чтобы вывести нужно cout<<название переменной;
cout<<a;

так же  после того как написал какой тип данных можно через запятую написать переменные и потом уже присваивать им значения

ещё можно происваивать значение после типа данных и переменной
например int a=5,v=6;

cin - штука чтобы пользователь задавал значение переменной как input()
 в пайтоне 
cin >> A; 
перед этим лучше писать cout<<"Введите число: ";

чтобы вывести значение с цифрами после точки
то надо перед операцией написать (double)
и в переменной написать double A;
------------------------------------------
массив
int a[]={2,4}
2 - имеет индекс 0
4 - индекс 1
чтобы обратиться
a{0} or a{1}
-----------------------------------------
template<typename T1,typename T2>
T2 sum(T1 a,T2 b)
{
    return a+b;
}

это шаблон функции
он нужен чтобы не делать перегрузку функции
то есть т1 и т2 могут принемать любое значение и складывать их
то будет выводиться только тип значения т1, это можно изменить
---------------------------------------------
стек
ну тут есть имба пример

у тебя есть тарелки и у тебя есть тазик если ты ьудешь ложить тарелки то тарелку которую ты положил 1 достанешь последней

а тарелку которую ыт положил последней достанешь первой
--------------------------------------------------------
как я понял рекурсия нужна для того чтобы кдалять обьекты которые уже вывели

int foo(int a)
{
    if(a<1)
        return 0;
    a--;
    cout<<a<<endl;
    return foo(a);
}
та функция принимает значение и выводит в обратном порядке
9 8 7 6 5 4 3 2 1 0

и потом она удаляет это,чтобы не занимать память
------------------------------------
указатели с++

допустим у нас есть переменная a то чтобы найти её путь нужно

int *px = &a;
в место инт может быть любое возвращаемое значение
вместо икс может быть любое название переменной
и вместо а может быть любая переменная

так же можно менять переменную
для этого нужно
*px = 10;

звёздочка нужна для разиминования 
---------------------------
*(arr + 3)
такой записью можно обращаться к элементам массива
и в циклах *(arr + i) = arr[i]
--------------------------------------------
допустим у нас есть проблема что переменная а не изменяеться из за того что функция которая добовляла бы к переменной 1 не видит а из за области видимости функции

для этого мы можем работать через адресы

int foo(int *pa)
{
    return (*pa)++;
}

int main()
{
    int a = 0;
    foo(&a);
    cout<<a;
}

то есть мы берем и в параметры функции вставляем что пользователь должен указать адресс переменной
потом мы берём и вставляем адресс переменной в параметры вызываемой функции 

если добавить к указателю 1 то мы сдвинем адресс переменной на 4 байт

-----------------------------------------------------------------

ссылки это штуки для того чтобы хранить данные
например
int a =5;
int &ref = a;
для обьявления ссыки нужно писать & перед названием самой ссылки

ссылка с английского reference

если прибавить значение к сылки то адресс не измениться 
изменитсья сама переменная содержащаяся в ссылке
например есил сделать инкремент моей ссылки то а станет равной 6

если присвоить значение ссылке то изменитья и переменная указанная в ссылке


-------------------------------------------------------------

cout<<"hello\n"; - \n перемещает следующие выводы на строку можно
пихать кучу \n если надо сделать отступ

если в сообщение добавить \t то это как пробел

так же можно вставить т перед сообщением
\\ - вывод \
\" - вывод "
\' - вывод '

-------------------------------------------------------------
операторы 
|| или
&& и
== равно
!= не равно
-------------------------------------------------------------


Константа
переменная которая не меняется
например дни в недели
const int a = 7;

-------------------------------------------------------------
фикл вайл
while(условие)
{
	действие
	счётчик a++
}
--------------------------------------------------------------
цикл фор 
for(создание переменной которая будет создана чисто для этого цикла;условие;счётчик a++,a+=2 и тд)
{
	тело
}

если обьявить переменную до цикла то она будет доступна всем и допустим она отработает один цикл и станет с значением 10

в следующем цикле надо это учесть
-------------------------------------------------------------
if,else if,else
if(условие)
{
	тело
}
break; нужен для того что бы программа могла перейти на некст действие(ставить после каждого ифа и элса)
else if(условие)
{
	тело
}
else(тут условий не надо типо если ничо  сверху не выполнилось то выполнять элсе)
{
	тело
}


---------------------------------------------------------------
#include<iostream>
using namespace std;

int main()
{
    const int size = 3;
    int arr[size]{1,2,3};
    
    for(int i=0 ;i < size;i++)
    {
        cout<<"\nelem "<<i<<" = "<<arr[i];
    }
}
вывести числа из массива можно с помощью цикла фор
нужно использовать константу чтобы было удобно и не запутаться
----------------------------------------------------------------
Рандомные числа
для этого нужно использовать библиотеку 
#include<ctime>
srand(time(NULL));
int a = rand();

чтобы ограничить генератор и сделать диапазон нужно
после int a =rand()%и до какого числа генерировать допустим %100

int main()
{
    srand(time(NULL));
    int a = rand()%100;
    int const S = 10;
    int arr[S];
    for(int i = 0;i<S;i++)
    {
        arr[i]=rand()%100;
        cout<<arr[i]<<endl;
    }
}
код чтобы присовить массиву рандомные значения

чтобы значения были рандомные но одинаковые({64,64,64,64,64})
нужно int a = rand()%100; перед циклом а в цикле  использовать переменную a.
 или же убрать  srand(time(NULL));.
--------------------------------------------------------
чтобы найти самый маленький эллемент в массиве нужно сделать так

нужно создать переменную которой присвоить 0 индекс данного массива

потом нужно создать цикл и в цикле фор нужно написать если данный эллемент по кторому мы сейчас бежим меньше чем 1 элемент в массиве
то мы присваиваем переменной следущий индекс пока не найдём самое маленькое число в массиве
 int v = arr[0];
    for(int i = 0; 5 > i;i++)
    {
        if(arr[i]<v)
        {
            v = arr[i];
        }
    }
--------------------------------------------------------------------
Двумерный массив состоит из коллон и строк

0|-0-1-2-3-4-5-6-|	                       
1|\-\2\-\-\-\-\-\|
2|\-\-\-\-\6\-\-\|
3|\-\4\-\-\-\-\-\|
4|---------------|

вот какой крутой пример я нарисовал
это что пример двумерного массива
тоесть у него есть строка ROW
и колонна COL

чтобы обратиться к какому либо элементу данного массива нужно
[ROW][COL]-тоесть в первую строку, во вторую колону

ROW and COL нужно задавать константами
const int ROW=x; 
const int COL=y;

чтобы обьявить массив
int arr[ROW][COL];
то есть в этом массиве х строк и y колон
так же можно сделат ьтак чтобы в ячейках лежал не мусор а 0 для этого нужно
int arr[ROW][COL]{}; - просто добавить {}

чтобы присвоить ячейке массива значение нужно
arr[индекс строчки][индекс колонны]=чо хочешь;

выводить +- также
cout<<arr[индекс строчки][индекс колонны];

ещё можно заполнять такие массивы вручню
arr[если тут ничего то можно писать миллион строк][тут надо написать опредёлонное значение]
{
	{и тут столько значений сколько колонн в массиве}
	{и тут столько значений сколько колонн в массиве}
	{и тут столько значений сколько колонн в массиве}
	{и тут столько значений сколько колонн в массиве}
}

-------------------------------------------------------------------------------------
заполнение двумерного массива с помощью цикла фор и вложенного цикла
 
   for(int i=0;i < ROWS;i++)
    {
        for(int j=0;j < COLS;j++)
        {
            arr[i][j] = rand()%100;
        }
    }

вывод массива с помощью цикла фор и вложенного цикла

     for(int i=0;i < ROWS;i++)
    {
        for(int j=0;j < COLS;j++)
        {
            std::cout<<arr[i][j]<<"\t";
        }
    std::cout<<std::endl;
    }
чот поломалось поэтому с этим std::
----------------------------------------------------------------------функции в плюсах

int sum(int a,int b)
{
    int result;
    result = a + b;
    return result;  
}
(так же можно не брать переменную и просто вписать return a+b)


вместо инт нужно вводить любое значение которое хочешь получить

хочешь просто вывести текст то void - типо ничего

в скобках параметры то есть при выводе вместо а можно написать 2,а вместо б написать 5

int c;
c = sum(2,5);
cout<<c;

то выведет 7

ещё в функции если прибваить к а которая в самой функции число то это не как не повлият на вывод,потому что переменная в функции копия переменной в  main

void fillarr(int arr[] ,const int SIZE)
{
    for(int i = 0;i < SIZE;i++)
    {
        arr[i]=rand()%100;
    }
}
ето функция для присвоения массиву значений(рандомных)



void printarr(int arr[] ,const int SIZE)
{
    for(int i = 0; i < SIZE;i++)
    {
        cout<<arr[i]<<"\t";
    }
} 
ето уже вывод массива
---------------------------------------------------
глобальный и локальные переменные

локальные переменные это переменные которые были обьявлены в теле какой либо функции или цикла
например
int main()
{	
	while (true)
	{
		int a = 5;
	}
}
это переменная в теле цикла вайл то есть если мы попробуем использовать эту переменную за  циклом то нам выдаст ошибку


также сущестуют глобальные переменные они обьявляються перед всем функциями 

#include<iostream>
using namespace std;
int a = 5;

int main()
{
	cout<<a;
}

в этом случае мы обьявили переменную до всего
и мы сможем использовать ёё везде
кроме функций
-----------------------------------------------------------------------------------
прототипы функций 

если мы попробуем призвать функции когда наша функция была обьявлена псоле функции main мы получим ошибку из за того что компилятор компилирует по порядку 

для фикса это ошибки нужно после подключений библиотеки и после использования пространства имён написать 1 строчку обьявлённой функции

допустим
void abc();
{
	
}

представим что эта функция была обьявлена после функции main 
и чтобы не было ошибки при компилировании
нужно

#include<iostream>
using namespace std;

void abc(); - вот эта строчка обьязательно нужна тк функции обьявлена после функции main

int main()
{

}

void abc();
{
	
}

-------------------------------------------------------------------------------------
оператор new нужен для того чтобы выделить место под данные

например в ссылку нельзя засунуть число потмоу что у ссылки нету области памяти
а если написать 
nt *pa = new int;
то под ссылку создаться ячейка в памяти и мы сможем положить в неё значение

также после использования этог значения его можно удалить оператоом delete
delete pa;
это нужно взять в привычку
как написал нью инт сразу надо писать delete тобы не забыть
---------------------------------------------------------------
null и nullpointer
нужны для присвоения указателю 0 адресс
pa = NULL;
---------------------------------------------------
чтобы создать динамический двумерынй массив нужно

создать две переменные для колонн и для строк

потом выделить место под строки

int **arr = new int*[Rows]; две звёздочки перед массивом означают что строки массива будут держать укахатели

потом мы должны выделить место под колонны с помощью цикла фор

for(int i=0;i<Rows;i++)
{
	arr[i]=new int[Cols];
}

псоле этого мы должны заполнить массив 

for(int i = 0;i < Rows;i++)
    {
        for(int h = 0;h<Cols;h++)
        {
            arr[i][h]=rand()%10;
        }
    }
это делаетсья с помощью вложенного цикла фор

после этого все нам нужно вывести массив и это тоже делаетсья с помощью вложенного цикла фор

for(int i = 0;i < Rows;i++)
    {
        for(int h = 0;h<Cols;h++)
        {
            cout<<arr[i][h]<<"\t";
        }
        cout<<endl;
    }

и есть великое правило то что надо удалять всё чем воспользовался
поэтому мы пишем цикл для удаления колонн

for (int i = 0; i < Rows;i++)
    {
        delete[] arr[i];
    }

и ещё не забываем удалить сам массив 
delete[] arr;
------------------------------------------------------------------------------------------

строки

например в переменную нельзя засунуть больше 1 буквы поэтому надо использовать строки

чтобы поместить слово или предложение в переменную нужно создать ммассив а не переменную
char a[]="hello";
cout<<a;
---------------------------------------------------------
define эта штука которая пишеться в начале программы где мы юзаем библиотеки
#define

в этот дэфан можно запихнуть константу которая будет иметь какое либо значиние

#define PI 3.14

если написать эту константу где то в коде то компилятор выведет число пи

так же это можно использоват ькак функцию

#define  Foo(x,y) ((x)+(y))

потом ее можно вызвать так же как и функцию 
cout<<foo(5,6) например

также с помощью нее можно включать и выключать отладку

например у вас есть цикл и вы для себя выводите начало и конец цикла а заказчику это не нужно
а просто закоментировать не варик так как потом как вы будете работать с этим проектом чтобы не путаться вам прийдёться всё раскоментировать

а тут всё просто

создаем константу с помощью дэфан

#define DEBUG

и например если мы хотим чтобы по нажатии двух кнопок все пряснения пропали нужно

ваше пояснение запечатать в схему
например


#ifdef DEBUG
	cout<<"пояснение";
#endif //DEBUG

если вы хотите скрыть все пояснения то просто комментируем константную переменную дефайн

если мы хотим добавить отображение ошибки то

#ifdef DEBUG
	cout<<"дебаг определён";
#else
	cout<<"дебаг не определён';
#endif //DEBUG

комментарий после эндиф не нужен

ifdef означает то что дебаг определён

endif чисто для того чтобы программа видела конец схемы

ifndef означает то что дебаг не определён
--------------------------------------------
тернарные операции

логическое вьетвление с помощью иф елиф и элс можно заменить
напрмиер
нам надо чтобы проверяло число 

(условие)?(cout<<"что нибудь"):(cout<<"2");
двоеточие означает else 
так же можно ставить операции
(условие)?(a+b):(a-b);

так же чтобы добавить проверку на равность числа нужно

(a<10)?(cout<<"число мепньше десяти"):(cout<<"число больше 10"):(cout<<"число равно 10");
-----------------------------------------------------------------

классы всякие вот эти ваши и обьекты

class human
{
public:
    string name;
    int age;
};

запись для создания класса


 human first;
    first.age=50;
    first.name="Oleg";
    cout<<"age = "<<first.age<<endl;
    cout<<"name = "<<first.name<<endl;
запись для создания обьекта в классе и заполнению его параметров и так же вывод на экран

------------------------------------------------------
так же можно в класс поместить функцию
например в класс человека поместить обьект котоырй выводит все другие обьекты на экран

class human
{
public:
	int age;
	int weight;
	
	void print()
	{
		cout<<age;
	}
};

чтобы вызвать эту функцию нужно 
human first;
first.print()
так же до этого заполнить другие обьекты которые мы хотим выводить
--------------------------------------------------------

модификаторы доступа к классам

есть 3 модификатор доступа

public
private
protected

нам пока что нужно только 2

это public and private

если мы сделаем параметры класса с модифактором доступа приват то их нельзя будет вызвать 

но мы можем вызвать эти самые параметры если вызовим их с модификатором доступа public


например

class point
{
public:
	void print()
	{
		cout<<y;
	}

private:
	int y;
};

в этом случае если мы попробуем заполнить 'y' то у нас не получиться но зато получиться вызвать функцию принт;
----------------------------------------------------------------

сть такие штуки как конструкторы 

сейчас представлю конструктор для заполнения двух переменных

point(int valuex, int valuey)
    {
        x = valuex;
        y = valuey;
    }

также есть конструктор который делает переменные нулевыми

point()
    {
        x = 0;
        y = 0;
    }


чтоыб вызвать эти конструкторы нужно создать обьект класса и в скобочках указать 2 значения для икс и игрик или оставить пустое чтобы эти значение стали нулевыми а не мусором

point a(5,10) например вот это
тут создаеться обект эй и мы присваеваем ему значения дял икс и игрик


--------------------------------------------------------------------

прототип метода

например у нас есть функия в классе и чтобы она не занимала много места то можно написать в классе начало функции и снаружи класса можно написать самму функцию например

class Myclass
{
public:
	void print();
);

void Myclass::print()
{
	 и тут описание функции
}

------------------------------------

дружественный метод класса 
например нам нужно спользовать обьект из одного класса в другом
для этого нужно в классе в котором наша функция написать 

friend  тип.возвращаемого.значения название.класса::и название функции с параметрами;

и в параметрах вроде нужно указать что обьект будет из класса из которого мы хотим взять обьекты и их значения;

тип возвращаекмого значения и навзание функции(название класса и ссылка на свой обьект);

чтобы это всё работало нужно обьявить класс до другого класса ну говно обьяснил но надеюсь не забуду;

и ещё чтобы пользоваться обьектами и их данными в функции другого класса нужно эту функцию вынести за класс

выше подробный гайд
------------------------------------

так ну тут у нас кароче тема с статик полем

ну кароче оно используеться как миннимум для создания айди

для этого нам нужно обьявить статик переменную в классе

static int count;

и в не класса написать

int class::count = 0;

это пример поэтмоу в реалиях можно использовать любой класс любой тип данных любую переменную и тд

после того как мы обьявили статическую переменную чтобы она выполняла роль порядкого счётчика айди нам нужно сделать инкремент count в конструкторе класса 

Class()
{
	count++;
}

 например мы создаём 2 обькта класса и  у нас переменная каунт становиться 2

чтобы вывести эту переменную можно вызывать ее через любой обьект класса

например мы в классе яблоко создали обьект яблоко1 то в си ауте пишет яблоко1.count
----------------------------------------------------------------------------------

ну карчое чтобы сделать айди нужно создать переменную айди и создаить геттерайди котоырй будет возвращать айди

и также в конструкторе нужно присваивать id = count

----------------------------------------------------------------------------------------
статический метод знает к какому типу он принадлежит 

я не понял зачем нужнен именно статический метод класса делать но впринципе это удобно потому что не надо писать this->

у меня там в файле есть примеры с статическими методами и там очень легкая логика

так тчо если что изи вспомню
----------------------------------------------------------------------------------------

ну хз чо писать

ну например то что в параметры функции можно сувать функции 

например rand 

в конструктор класс тоже можно

arr[i] = image::Pixel(rand()%255, rand()%255, rand()%255); вот к примеру я присваиваю в 0 ячейку массива обьект пикселя с рандомными RGB (red green blue)

	for (int i = 0; i < Lenght; i++)
	{
		arr[i] = image::Pixel(rand()%255, rand()%255, rand()%255);
		cout << arr[i].GetRGB() << endl<<endl;
	}

вот фор для того чтобы генерировать ргб и выводить на экран

функция гетРГБ тупо выводит ргб по одному


так же можно создать динамический массив 

 int Lenght = 5;

 image::Pixel* arr = new image::Pixel[Lenght];

то есть мы указываем фунциию и указатель на массив потом выделяем дял него память
-----------------------------------------------------------

агрегация и композиция 

композиция когда класс и в него вложенный класс взаимно связаны

например класс человек не может сущестовать без вложенного класа мозг и наоборот 

Агрегация это  когда класс может использоваться с дургими классами и с ними он не взаимосвзяан и может существовать без другого класса
------------------------------------------------------------------

max_element(vec.begin(), vec.end()); находит максимальный элемент в векторе

























